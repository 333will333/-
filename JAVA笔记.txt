JAVA:

1月21日：
前天看了考试成绩，挂了3科，明天就要去新都挨骂了。
今天先记一下这两天看JAVA的一些可能会用到的东西。
按顺序来：先记各种数据类型，然后是运算符，再就是从第一份笔记中看的一些东西。
数据类型：从小到大
byte：最小的数据类型，只有1个字节，在参与运算时，会转换成int型。
short:2个字节，
int:4个字节，
long:8个字节，
char:2个字节，而且可以用来存放汉字（由于编码的原因），
float:单精度浮点型变量，4个字节，但注意java中的浮点型数据都是默认double型，若要使用float型数据，则要在小数后加f
double:8个字节，精度更高。

然后是数组，以前在两个JAVA视频中都有关于数组的讲述，但学C语言时，感觉数组并不难，而且也不是很常用，现在想想真的是坐井观天了，看来数组不管在哪种语言中都很重要，要熟练运用的。
一维数组：没什么好说的，
二维数组：其实基本概念也没什么好说的，但第一份笔记中，写了二维数组每一行包含的列不需要相同，刚开始还没懂，后来想应该是指每行定义的列数不需要相同，以后可能会用到，记一笔。

然后是位运算符，以前学C语言时也没好好学这一块，现在先记一下有些什么，用到时，再结合实例细学。
按位与：&
按位或：|
按位异或：^
按位取反：~
左移：<<
带符号右移：>>
不带符号右移：>>>

然后是几个常用术语的定义：
OOP：面向对象编程，也是java的核心编程思想，不过不好理解，刚开始学时，我还当成是面对用户的意思，实际应该是指：针对需要实现的模型中的一个个个体的意思，而编程时，就是把一个个个体单独编写出来，再用这些个体来组成整个模型。
与之对应的面向过程编程则是另一思想，说实话还不懂。

入口函数：几乎每个java程序都有的，虽是个函数，其实是整个函数的入口，代码如下：
public static void main(String []args)
public:是访问限制符，同类，不同类，同包，不同包都可以访问。后面可能会统一记一下这些基础知识。
static:指明该函数为静态函数，和不同方法不同的是，这些静态的方法或变量不用实例化就会存在，并且可以通过实例中的方法访问，但静态方法却只能访问静态变量，方法。
void：该函数无返回值，
String []args：为使用者和程序交互提供路径（然并卵，不懂）

构造函数：以前学时几乎没懂这是个啥，现在大致知道了，就是在通过类模型定义实例时（也就是实例化），给类的变量附一个初始值，之后可以根据需要修改，如果不写构造函数，编译器也会设置一个为空的构造函数。

方法的重载：
是用在子类的方法和父类的方法不同时使用，重载的方法和原方法名相同，通过方法的参数个数，类型（也可两者都不同）来区分。而编译器会选择对应匹配精度最高的使用。

几种代码块的定义：（大括号之间）
普通代码块：没有定义变量的代码块。
构造代码块：定义类中变量的代码块。
静态代码块：定义静态变量的代码块。

内部类是一种很玄学的玩意儿，顾名思义，但可能会用到，就不记了。



1月31日：
刚刚看了一个JAVA的笔记，介绍的都是一些有关程序编译的东西，还是有些用的，记一下。
字符串的值是用双引号括起来，如：String a="sjfdklsfj";
JAVA的控制台编译，以前看视频时，也不太懂。
javac 源文件名.java  是编译java文件
java 主类名（实际上和源文件名一样，因为命名规则） 是执行该类（必须要有主函数，public类）

带包运行指令：javac  -d  源文件名.java 
带包执行指令：java -d 主类名
执行带包类时，要加路径。（后面补充）


韩顺平第9讲：静态和封装
 静态变量（类变量）：
在一个类中定义一个静态变量，所有的同类对象都可以访问，是所有同类类共享的。
在静态方法中无法访问非静态变量。
静态方法也可以被所有的相同的类和对象访问到，但习惯上用类名来访问静态变量和方法。
静态区域块的代码只会执行一次，而且一定会执行一次，不管是否实例化对象。

封装:将类变量？和类方法？封装，使得该程序的其他部分无法直接访问，只能被授权之后，才能访问，常用的方法是，通过成员方法来访问，如get()方法，get方法类用return 返回想要访问的变量。

变量修饰符：                                     访问范围
共有的：public		同类，同包，子类，不同包
保护的：protected		同类，同包，子类
默认的：无		同类，同包
私有的：private		同类
注：同类是指同一个对象，而不是指同一个类定义的所有对象。



2月2日：
（韩顺平第11讲）
方法的覆盖：具体的内容已经记过了，但有一个注意事项。
范围问题：子类方法在对从父类继承的方法进行重载时，其重载后的方法范围必须大于等于原方法，也就是访问限制符的大小。（复习一下：public>默认的>protected>privete）

约瑟夫问题：也是丢手帕问题，具体内容就不说了，很简单。但在解决问题时，用到了结构体，链表，指针，以前在学校学时，我竟然天真的认为JAVA中没有这些东西，哎，游戏误人啊。
先说结构体，在今天看的实例中，他是定义了一个类，而这个类中有两个属性，一个是编号，一个是nextchild，顾名思义，就是下一个孩子，实际上是用来存放下一个孩子的地址。再通过循环和引入的参数来创建不同的孩子。
然后是链表，之前已经有了创建结构体的办法，于是在循环中加入给nextchild这个属性赋值的语句就行，如temp.nextchild=ch;虽然没有指针的形式，但作用和链表已经一样了。
另外还必须得说的是，创建一个类作为结构体和创建一个对象不是一回事，和C语言不同的是，JAVA中创建完了类后，还要在主函数中创建新对象，类只定义一次，但对象就是根据需要来确定的，不过应该大都是用循环体来创建的。
还有一个以前不知道的东西，就是参数的设置，比如这个例子中的：
public Kset(int k)
{
       this.k=k;
}
这个方法就是用来从外部引进参数k的值，同时又可以保密k的值不被外部方法访问到。以前写报告时，一直似懂非懂这东西有什么卵用。
约瑟夫问题中有个边缘条件需要注意，每个开始数的人都是从自己开始数的，所以边缘条件从1开始，还不加等号。

最后是很重要的编程思路的问题，以前也一直没注意：
在编写之前，要把解决问题的方法弄清楚，而且要分成一步一步，然后再一步步的编程实现，这样思路会清晰很多。

（韩顺平第12讲 ）
多态的定义：通过指向父类的指针来调用子类的方法。就可以实现如同：Animal ch=new cat();

然后是对于eclipse的发展历程介绍，eclipse是一个叫iBm网站编写的，在eclipse刚出来时，只能用于编写JAVA和C的程序，很局限，但由于太好用了，一个小公司叫myeclipse开发了一个插件，在下载后，就能编写各种程序，如JSP等等。

多态的实现
主要是通过两个实例来完成演示，
第一个实例较简单，只是用一个Animal父类，通过继承来创建Cat,Dog类，并且在这两个子类中进行方法重载，然后再主程序中进行定义和调用时，通过Animal ch=new Cat();的语句进行定义对象，这样做的原理是：编译器能够通过父类的方法，以及继承的关系，找到子类中的重载方法，当然，若没有重载方法，就会调用父类的方法，也不多态了。

第二个实例有些复杂，但也不是很难理解，承接第一个实例的代码，这个实例中，又加入了食物Food,主人Master,两个类，并且Food类中，用showName方法，同时还有鱼fish,骨头bone两个子类并进行方法重载,Master类中，有喂食Feed方法。重要的在主函数的调用，通过代码来看吧，不好叙述：
Feed 方法定义
Feed(Animal ch,Food f)
{
   ch.cry();
   f.showName();
}

主函数调用：
Master a=new Master();
a.Feed(new Cat,new fish);

2月6日：（韩顺平第13讲）
抽象类：和现实中的抽象定义一样，抽象类也不能被实例化，仅仅是作为一个供其他类继承的模型而已。
代码实现：
抽象类的定义：抽象类需要用abstract修饰，而且抽象类中没有主体的类（即未被实现），其中的抽象方法也要用abstract修饰，但也可以有非抽象方法存在，这些方法可以实现。
抽象类的使用：抽象类的子类通过继承获得抽象父类的方法，但和普通继承不同的是，抽象类的子类需要重新定义实现这些方法。这所以继承抽象类，是为了在调用时，方便使用多态（参上一讲）。只需通过父类一个，就可以调用所有的子类，比重载更加简洁明了。

接口：
接口的定义：使用interface(也是接口的英语)，接口中定义的方法都不能实现，（有点像抽象类，但抽象类可以有实现了的方法，接口一个都不能有），而使用接口的类必须实现接口中定义的所有方法，若接口是继承的，那么连同其父类方法也要实现。
接口的调用：在我看来，接口的用处就是可以不通过继承，就让没有关系的类能够相互调用方法，也就是达到类似多态的效果。
代码实现：
接口定义：
interface Usb {
        method1();//无主体
        method2();
}
接口实现：
class Camera implements Usb{
        method1(){
	
	}
        method2(){
	
	}
}
接口的继承：
和类的继承一样，interface Aaa extents Kkk{
}
接口使用：
在需要使用接口的类中定义方法
public useUsb(Usb usb){
         usb.start();
         usb.stop();
}
主函数中必须要实例化所有要用到的类，不管是调用还是被调用的类。然后再使用接口调用方法。
注意事项：难得记，就直接抄了，不难理解
1.接口不能被实例化。
2.接口中的方法不能有主体。
3.一个类可以实现多个接口。
4.接口中可以定义变量，但默认这些变量都是static，并且是final的（虽然不知道是什么鬼）。实际使用中，一般将静态变量定义在接口中使用。访问方法：接口名.变量名。
5.接口不能继承类，但接口可以继承接口。



2月8日：（韩顺平14讲）
继承和接口对比：
继承在复制父类时很快捷，但由于父类和子类之间的连带关系，如果父类出错或需要改动，那么所有的子类都将受影响。接口却只是方法层面的关系，可以任意的改动内容，可以无限制添加实现接口的类，这样其他类就可以调用这些接口方法。

课程中使用的实例是销售汽车，先定义一个关于汽车的接口，然后不同的车分别再实现接口，然后再由一个汽车店的类调用这些方法。

然后是前后期绑定：
前期绑定：相对于编译器来说，在没运行时就明了的变量值，就是前期绑定。
后期绑定：在运行后编译器才能知道的变量值。

final的使用：
final修饰类：该类无法被继承。
final修饰方法：该方法无法被重载，覆盖。
final修饰变量值 ：该量为常量，值不变。常量命名一般为XXX_xxx.




（韩顺平16讲）
对象数组：和普通数组一样，是用来存储同类型数据的数据结构，只不过对象数组存储的是对象而已。其实际原理和用处和链表相似，数组中存放的实际是指向对象的指针。
dog[i]=new dog();问题：由于对象数组只是分配了空间，实际仍是空的，不能直接赋值，要重新定义才行，也就是再为每个对象分配空间。（没想通就先记住）
异常抛出：后面会详细讲，不过听上去好像后三种异常，而在实例中使用的处理异常的方法就是不管，让别人去处理，就是异常抛出。
控制台输入：用了一个很长很怪异的语句，没用Scanner，可能是另一种从控制台输入的方法。
流：不懂。
字符String转float：使用的语句是：
float weight =Float.parseFloat(s_weight);
weight是此时专门定义的，用来存储转换类型后的值
s_weight是之前用来存储字符型值的变量，所以加了s_来命名，而数值型则没加。

for循环重复定义两个i，不会冲突，但不知道为什么。



（韩顺平第17讲：排序）
字符串比较




















（韩顺平第30讲：布局管理器）
共有三种布局管理器
边界布局
流式布局
网格布局


（初试坦克大战）
布局管理器：
1.定义组件
继承JPanel，在MyPanl中完成界面绘制。
覆盖JPanel中的画笔类。可以理解为画图工具中的画笔。
调用父类方法完成初始化。
开始绘制。
让主类继承JFrame。
实例化MyPanel。
在主类中定义构造方法

创建Tank类：
定义坦克的横纵坐标（以左上角为准）以及从外部获得参数值的构造函数，用于所有坦克继承。
创建Hero类，继承Tank类，并调用父类的构造方法初始化。（记住定义在构造块（占坑），赋值再构造函数（填东西））。
在面板类中实例化英雄坦克类，同时传入参数（实质只是位置点的坐标，图形此时还没画）。（实例化对象并不需要一定在主类中）


事件处理机制： 
1.在引进包中增加java.awt.event.*;
2.事件发生源是MyPanel,监听源是继承自JFrame的3.Demo,因为JFrame更加靠近底层。
4.实现KeyListener接口,用提示。使用该接口中的按下方法。
5.在主类的构造函数中注册监听，
6.事件处理：在接口方法中用if语句和键值比较。
7.图像移动：在接口方法中对横纵坐标加减，并并在press方法中调用repaint函数来重绘：this.repaint();
总结：
关于事件源，事件对象，事件监听器的关系
事件源：发生事件，并由事件监听器在事件源注册。
事件对象：传递事件信息。
事件监听器：对事件进行处理和反应，也就是根据需要重载事件方法。

坦克绘制的封装：
通过在MyPanel中定义绘制函数，并传入位置参数，方向，以及最重要的画笔，才能绘制。
可以通过多个switch来选择坦克类型，颜色，方向等属性。



2.创建组件（在构造函数中完成 ）
3.添加组件
4.设置窗体属性（定义大小）
5.显示
