

第1章：链表（代码实现记录的差不多，但还是要看看书，看有没漏洞）
今天主要在做数据结构第四次的作业，题感觉不是很难，因为都是补充代码，看了教学视频就可以作，但这三个代码的价值在于完整的完成了双向链表，堆栈，队列从创建，存入数据，删除数据，检验是否为空为满，以及输出数据。但也有一些健壮性没有考虑，下面总结一下这三种顺序结构数据的代码结构。

链表：
首先是结构体的定义：
单链表：data数据域；next后继指针（可再定义一个lenth来记录当前链表长度，在insert函数中会用，也可再结构体外部单独定义变量来储存，我认为更方便）
双向链表：；data数据域；next后继指针；prior前驱指针，其中头结点的prior指向NULL，尾节点的next指向NULL。
循环链表：定义结构体时，和单链表一样，只是尾节点会指向头结点。
双向循环链表：前两种结合即可。

然后是构建链表：
函数名：node *create( )或void create(pnode head)
注：第一种定义法在主函数中要定义一个*head接收函数的返回值（是头结点的地址）。第二种则需
将主函数中的地址传入函数，进行加工，但不用接收返回值，所以用void。

然后是链表节点开拓：
用for循环，定义最大长度来限定表长，循环内部使用q指针动态分配内存，开辟新节点。

然后是链表读出，查询：
很简单，for循环，p->next!=NULL，循环内用if语句判断p->data==n;或printf；

链表插入：
单链表：先修改插入节点s的后驱指针，再修改p的后驱指针。注：若是顺序改变，则会导致断链，即s以后的链丢失。
双向链表：修改顺序：先修改新插入的节点的前驱后继指针，再修改p->next节点的前驱，最后才修改p节点的后继指针。注：如果顺序改变，特别是提前修改p节点的后继指针，很可能会造成断链，即丢失后续节点地址。
循环链表：在非尾节点处插入，操作和单链表一样，尾节点处插入则先改新节点后继指向头结点或第一个节点，（双向链还要改前驱），再修改原来的尾节点指向新节点。
双向循环链表：略
总结：插入节点修改指针时，一定要从后往前改，先改新节点，先改前驱，后改后继。

链表删除：如果是双向链，则先修改下下个节点前驱，再修改当前节点后继；单向则只改后继；删循环链尾部的话，则倒数第二个节点指向头结点。

链表连接：？？？？？
单链表：先循环查找到第一个链表尾部，修改尾指针，指向第二个链表的第一个节点（注意不是头结点，是有数据的第一个节点）。
双向链：先和单链表操作一样，然后修改第二个链表的第一个节点前驱。
循环链：先和单链表一样，然后修改第二链表的尾节点，指向第一个链表的头结点？？？？
双向循环链：参上。

写了一些题，双向链表插入，删除时，指针的修改（此处的注意事项就是之前总结的:修改顺序是从后向前，从新节点到旧节点）。
还有一些关于队列的题不是很熟，有一题是将队1中的元素出队，经过一个if（q->num[i]!=m）语句筛选后入队2，该算法的用途就是将队列1中值为m的元素删除。
还有一道是先在一个循环中将队1出队，存入队2，同时m++，记下队1的长度，再在一个循环中，将队2出队，存入队1，队2，最后效果是将队1元素复制到队2（那m有什么用？？？）。




第2,3章：堆栈（有一些记载，但还是不够精细，还要重看）
栈创建：
结构体定义：定义一个数组，一个栈顶指针。
在主函数中，初始化栈顶指针为0，即栈为空。

入栈操作：定义push函数，引入

先评讲了上次的作业，其中有一个地方值得注意：
在双向链表插入元素操作中，在中间插入都还简单，但若是插在链表尾部，此时插入操作会不同，就得用if（p->next==NULL）来另外写插入语句，最主要的是在此时没有修改前驱指针的操作，因为p->next为NULL，当然就没有p->next->prior。

然后就是栈堆的应用：
1.逆序储存：由于栈有LIFO的特性，按顺序存入后，输出时就为逆序。
2.当有n个入栈元素时，共有C(2n,n)/(n+1)种出栈序列。



第4章：数组（没有记，但应该也不是重点，但还是要看）
最重要的也是唯一有价值的是对称矩阵的压缩：矩阵中能够压缩的只有对称矩阵，
具体方法是：通过记录矩阵上半或下半部分，再加上主对角线上的元素，按照行序或列序为主序，用一维数组从左到右或从上到下存储数据即可。
然后还有个稀疏矩阵，就是注意是用三元组来存储的，就是三元组表格，或十字链表（感觉多此一举），分别存储元素的横纵坐标和值。



第5章：树（从树和森林的转化之前的没记，后面记的也很粗糙，要重点复习，特别是有关计算的东西）
先是二叉树的介绍，然后最重要的关于二叉树的不同度的节点数，弧数，树高的计算，接下来记一下：
先是某一层的最大节点数：2的（i-1）次方。
然后高度为k的树的最大节点数：（2的i次方）-1。
度为1的节点数=度为2的节点+1

然后是满二叉树：每一层的节点都排满。
完全二叉树：除最后一层外，都排满。
然后是关于完全二叉树的计算：已知节点编号，或在某一层的第几个，求树高等等，解法就只有带2的次方数来计算了。

树的先，中，后序遍历：
大概有两种题型：
已知树的结构，要求写出树的某种遍历序列。
已知树的两种遍历序列，要求写出树的具体结构。

树和森林的转化，
树转森林：1，先把多叉树按层摆列对齐，2，在亲兄弟之间加线，然后去掉两代之间除长子的线。3，调整形状。
森林转树：1，先将树按层摆好，2，从左向右将亲兄弟之间连线，3，以最左一棵树的根为树的根，调整形状。

然后是哈夫曼树的计算:
不带权路径值：就是路径长度。
带权值路径值：所有路的路径长度*权值
最后是哈夫曼树的创建：
从数据中，选出最小的两个，合成一个一个新数，构成树，以此类推。
在表格中创建时，要注意选中数据的摆放顺序，要么先选出的在前，或小的在前。

树的的先序，中序，后序存储在数学中的应用都先不说，只说通过中序序列和另一种序列推出第三种序列的方法：
首先看不是中序的序列，前序就看第一个字母，后序看最后一个字母，因为这个字母就是树的根节点，然后根据中序排列将左右部分的元素分开，然后分别根据另一序列确定第二层节点，以此类推，层层确定即可。



第6章：图（除关键路径外的内容都没有，需重看，且要注意计算的东西）
先是几种表的特点，缺点，完成某个操作的时间复杂度（注意：无向图没有邻接表等等的定义）：
邻接矩阵：用矩阵来记录节点的连接情况，无向图的非0数是同样的有向图的两倍。
优点：可以很好的储存稠密图。
缺点：不管有没有连接，都需要给每一个组合分配空间，造成空间浪费。

邻接表：使用数组和单链表结合的方式。在数组中存储节点的值和指针域，通过指针域指向其出度的节点。
优点：可以很快找到某节点的出度。
缺点：很难找到某节点的入度节点，需要遍历整个邻接表（数组和所有的单链表）该操作的时间复杂度为：O（e）或O（n+e）该值是网上的。所储存的节点数受数组长度限制。

逆邻接表：具体结构和邻接表一样，但其指针域指向该节点的入度节点。
优缺点：和邻接表相反。

十字链表：其结构是邻接表和逆邻接表的组合，就像一个二维数组一样，由两个数组组成，一个存放节点的入度指针，一个存放出度指针，每存在一条弧就定义一个结构体其中有记录出入度节点序号和权值，而数组中的指针则指向第一个出度或入度结构体，而后面的出入度结构体是通过前一节点的指针串起来的，仍使用单链表，只不过出度链和入度链会公用某些结构体。

然后是图的遍历：
深度遍历：先遍历一个节点，然后遍历该节点的任一邻接点，然后再遍历新选中节点的任一邻接点，一直重复，直到没有邻接点，然后回溯，在选择其他邻接点遍历。
广度遍历：先遍历一个节点，然后遍历该节点的所有邻接点，然后选择从中一个节点，再重复以上步骤。

最小生成树：
普利姆：先任意选择一个节点，选择权值最小的路径，然后将这两个节点标记，再选择这两个标记节点的所有路径中权值最小的路径。然后就是重复以上步骤，但要注意：选择路径不能形成环。
该算法属于贪心算法，时间复杂度为O（n的平方）

克鲁斯卡尔：在所有路径中选出最小的一条，然后再在剩下路径中选出最小的，如此重复，但同样不能成环。
算法复杂度O（e log e）。

然后是拓扑排序：该排序方法是用来检测AOV图是否有回路。
方法：先选择一个入度为0的节点，输出该节点，然后去掉该节点和其连接的边，然后再找入度为0的节点，重复以上步骤。
最后输出的节点数若等于总结点数，则该图没有回路。若小于总结点数，则有回路，需重新设计该图。

关键路径：关键路径最重要的是每个节点最早呈现时间和最晚呈现时间的算法。
最早呈现时间：就是指该项目节点最早在什么时候能开始，这取决于该到达该节点的最长时间决定。具体算法是：从第一个节点开始，每条路逐个加，到达某个节点的最大权值和即是。
最晚呈现时间：是指该节点在不影响按时完工的条件下，最晚的开工时间，同一个点，最早最晚呈现时间之差即是在该节点可以拖拉的时间。具体算法是：从最终节点呈现时间开始，逐个减去权值，即得。
以上东西用工程流程理解会更好。

然后是关键路径：这个还好算些，其中也有贪心算法，贪心算法就是指每一步都只考虑局部最优解，从而求的全局最优解。
关键路径算法：从起始点开始，每一步都写出所有入度点的值，再选择权值最小的点，再重复，每一个点都选择最小的权值和，即得。



第7章：查找（完全没记，但该章是重点，要重看，特别是计算有关的）
先记一个小知识，做卷子时遇到的：
键值：可以特定标识一个数据元素的值。
然后是顺序表的查找：（注意和后面的有序表区分开：顺序表指的是数据存储的方式是用的顺序表，而有序表指的是表中的数据已经是有序数列了）
顺序表的查找：其实就是遍历查找，从表的第一个元素开始查找，直到查找成功。
平均查找长度：最好查找情况和最坏查找情况的和除以数据个数。
有序表的查找：
折半查找：

二叉排序树：

平衡二叉树：

哈希查找：

冲突处理：
线性探测：
再哈希法：
链地址法：
公共溢出区法：



第8章：排序（内容完整）
1.插入排序：
直接插入排序：先将这组数据的第一个数视为一个有序数列，然后通过每次插入一个数的方法来使整体数据有序。
值得注意的有以下几点：
1，在循环中，使用一个temp的变量来存储要插入的数据。
2，进行插入比较时，要从插入数据的前一个数据开始比较，因为这样比较时，当比较到有数据比插入数据小时，就可直接跳出内层循环，开始下一轮插入操作。
3，进行比较后，如果当前数据比插入数据小时，插入数据存入上一位置，比插入数据大时，则将当前数据移动到上一位，再继续向前比较。
4，边缘条件：外循环：for(i=1;i<=lenth;i++)注意外循环里i是从1而不是从0开始的。内循环：for(j=i-1;j>=0;j--)由于是倒着比较，故为j>=1,j--。
5；时间复杂度：O(n的平方)，空间复杂度：O(1).

希尔排序：是插入排序的改进版，通过增加一个增量d来使数据大跨度的交换，更快的到达最终位置。
具体代码没看，但我知道是通过对增量d--的操作来逐渐缩小范围，直到d=1时，变为一个直接插入排序，但和直接使用直接插入排序不同的是，经过前几轮的交换（也就是对间隔为d的数据进行插入排序后），该数列已经基本有序，再使用直接插入排序可以节约时间成本。

2.交换排序：
冒泡排序：C语言中会的唯一一种排序方法，不过现在才想清楚，冒泡排序还是分两种的：沉底和上浮。
沉底：从第一个数据开始，和下一个数比较，若前一数据小于后一数据则不换，反之则换，但不管换与不换，都将游标指向下一位，直到倒数第二位和最后一位比完，再跳出循环。此时，该数列中最大的数已经沉底，所以，下一次循环时的后界就要减一。
上浮：应该和沉底是反的。

快速排序：快速排序中定义了一个疏轴的概念，通过疏轴将数列分成两部分，从疏轴右边的末尾开始进行比较，交换数据后，改变方向，从左边第一个开始比较，当疏轴左边选中数据大于疏轴时，将疏轴与该数交换，然后从疏轴右边段末尾开始比较。
代码实现：
在主程序中，就按部就班的写，外函数只调用一次，而内函数不在主函数中调用。
在外函数中，需要传入first,end 两个值，首先会调用内函数，然后两次递归调用自己，传入的值分别是：（first,mid-1）和（mid+1,end）,而mid的值就是在调用内函数时的返回值。
最核心的算法在内函数，内函数接收到first和end的值，并将first对应的数据视为疏轴，开始比较。比较和交换通过两层循环实现，第一层是判断first<end，而终止情况是first=end，意为此时疏轴已到达最终位置。第二层是完成对每一段的比较，先在疏轴右端末尾开始比较，因为定义时已把第一个数作为疏轴，此时只有右边有数据。当右端比较时，大于疏轴则end--，小于疏轴则将小于的数据写入疏轴当前位置，然后将交换数据的位置作为疏轴的位置。然后进行在左端的循环，同样的道理，只不过是从第一个数据开始，为first++，由于外循环和两个内循环都是使用while，所以循环次数不必注意，只要边缘条件正确即可。最后，在外循环跳出，内函数返回值前，要把疏轴pivot的值赋给a[first],此时first=end，赋给谁都是一样的。

3，选择排序：
简单选择排序：对一个序列进行扫描，每次选出无序部分的最小数，与无序部分第一个数交换，直到只剩一个数据没插入，即可。
代码实现：
对整个数列进行比较，两层循环，外层循环i值代表当前有序的下一位，即要与最小值交换的数，选出最小数，记录下下标，若该数的位置不为最终位置，则与有序部分的下一位交换，反之则不。通过if中的flag变量来记录是否需要交换。

堆排序：通过完全二叉树来排序，先将序列表示成完全二叉树，在从最后一个非叶子节点开始，（此处以大堆顶为例）将此节点和其叶子中的最大值找出，作为子树根节点。以此类推，直到根节点。
没看代码。

4，归并排序：归并排序也要用到递归思想，先把数据分为两个或多个部分，然后在各部分中排序，然后再将两个或多个有序序列合并排序，由于此时各部分都已经有序，合并时可大大降低比较次数。

5；基数排序：按一定的先后顺序使用关键词，对数据排序。值得注意的是：在这种排序中，越后作用的关键词优先级越高，在排序依据中更重要。