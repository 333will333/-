10月8日（星期天）-10月14日：
  今天主要是在赶作业，主要看的离散。
  由于前段时间复习C语言，所以欠下很多内容。离散就是基本从头开始看的。我先从E公式开始看起，也就是恒等演算，复习了摩根，蕴含表达式，吸收式，这些还算简单。然后就是在逻辑推理中要用到的永真蕴含式，即Q公式，按顺序来应该是：加法，简化，假言推理，拒取式，析取三段论，前提三段论，合取式。
最后是之前一直没背过的，含有量词的永真式和永真蕴含式。其实是有规律的。在要背的公式中，
先是任意辖域合取，可将任意辖域分配，任意合取符号都不变。
然后是存在辖域析取，可将存在辖域分配，同样符号都不变。以上两个公式都是恒等式可逆用。
翻篇是存在辖域合取和任意辖域析取，在辖域分配后，符号不变，但是永真蕴含式，而不是恒等式，不能逆用。
然后是辖域内是蕴含式的公式：
前件是函数，后件是常量，辖域扩张后，包含后件，任意存在量词互换。
前件是常量，后件是函数，辖域扩张后，包含前件，量词不用转换。
最后最特殊，存在量词辖域包含两个函数蕴含关系，辖域收缩后，前任意后存在。
前存在后任意，统一量词后，统一为

然后是java视频，看到介绍类和方法。其实在我看来，类即对象，是用来描述一个事物的结构体，而这个结构体里的每一个变量属性，就是用来描述这个对象的一个特性，如描述人：name,age等等。然后就是方法，其实就是定义之前描述对象的动作，在对象中引用这些方法，就如同让这些对象做这些动作，如:count,run,speak.
然后是Java语言的语句：
打印，即输出：prinln("字符串"+变量)；
定义class,public,packge;

接下来是累计的问题：
首先还是离散数学，对于恒等演算难度较低，基本没有问题，但对于逻辑推理，就有些困难了，考试中也是逻辑推理题不会。分析来看，主要是I,Q类的公式不熟，也就是含量词的部分和恒等演算的后部分，还要加强。

然后是模电，上周几乎没有看，上课听了一下，但还是欠了很多内容，也该补补了。总感觉要考试了。下面说漏洞，第一章，就是那种电源，电阻，以及新的计算方法，学的还不是有太大问题，但是第二三章就有点飘了，主要是C语言考试和难度提升（和自己没学好）。第二章是讲电容，电感的，我还没细看，但我推测应该是讲在交流电情况下，电容，电感会被等效成电源，或电阻，或开路，短路。至于第三章，几乎没什么印象。

然后是三门编程专业课：
现在花时间最多的还是数据结构，14号值得纪念的日子，老夫的第一个链表终于跑通了。但现在，由于之前在创建链表函数卡住了，我的水平完全赶不上老师要求，循环，双向，循环双向链表都需要练习编写，而栈，队列也要写。

JAVA：跟着视频走，应该不会有太大问题，主要还是进度太慢，需加紧，难度应该不是很大。

数据库：主要问题是SQL server使用不熟，语句背不到，建表思想还好说，还要练习才行。
7-20

10月15日：
今天主要在做数据结构第四次的作业，题感觉不是很难，因为都是补充代码，看了教学视频就可以作，但这三个代码的价值在于完整的完成了双向链表，堆栈，队列从创建，存入数据，删除数据，检验是否为空为满，以及输出数据。但也有一些健壮性没有考虑，下面总结一下这三种顺序结构数据的代码结构。

链表：
首先是结构体的定义：
单链表：data数据域；next后继指针（可再定义一个lenth来记录当前链表长度，在insert函数中会用，也可再结构体外部单独定义变量来储存，我认为更方便）
双向链表：；data数据域；next后继指针；prior前驱指针，其中头结点的prior指向NULL，尾节点的next指向NULL。
循环链表：定义结构体时，和单链表一样，只是尾节点会指向头结点。
双向循环链表：前两种结合即可。

然后是构建链表：
函数名：node *create( )或void create(pnode head)
注：第一种定义法在主函数中要定义一个*head接收函数的返回值（是头结点的地址）。第二种则需
将主函数中的地址传入函数，进行加工，但不用接收返回值，所以用void。

然后是链表节点开拓：
用for循环，定义最大长度来限定表长，循环内部使用q指针动态分配内存，开辟新节点。

然后是链表读出，查询：
很简单，for循环，p->next!=NULL，循环内用if语句判断p->data==n;或printf；

链表插入：
单链表：先修改插入节点s的后驱指针，再修改p的后驱指针。注：若是顺序改变，则会导致断链，即s以后的链丢失。
双向链表：修改顺序：先修改新插入的节点的前驱后继指针，再修改p->next节点的前驱，最后才修改p节点的后继指针。注：如果顺序改变，特别是提前修改p节点的后继指针，很可能会造成断链，即丢失后续节点地址。
循环链表：在非尾节点处插入，操作和单链表一样，尾节点处插入则先改新节点后继指向头结点或第一个节点，（双向链还要改前驱），再修改原来的尾节点指向新节点。
双向循环链表：略
总结：插入节点修改指针时，一定要从后往前改，先改新节点，先改前驱，后改后继。

链表删除：如果是双向链，则先修改下下个节点前驱，再修改当前节点后继；单向则只改后继；删循环链尾部的话，则倒数第二个节点指向头结点。

链表连接：？？？？？
单链表：先循环查找到第一个链表尾部，修改尾指针，指向第二个链表的第一个节点（注意不是头结点，是有数据的第一个节点）。
双向链：先和单链表操作一样，然后修改第二个链表的第一个节点前驱。
循环链：先和单链表一样，然后修改第二链表的尾节点，指向第一个链表的头结点？？？？
双向循环链：参上。

堆栈：
栈创建：
结构体定义：定义一个数组，一个栈顶指针。
在主函数中，初始化栈顶指针为0，即栈为空。

入栈操作：定义push函数，引入


10月16日：
首先是数据结构：
先学的是树和森林的转化，
树转森林：1，先把多叉树按层摆列对齐，2，在亲兄弟之间加线，然后去掉两代之间除长子的线。3，调整形状。
森林转树：1，先将树按层摆好，2，从左向右将亲兄弟之间连线，3，以最左一棵树的根为树的根，调整形状。

然后是哈夫曼树的计算:
不带权路径值：就是路径长度。
带权值路径值：所有路的路径长度*权值
最后是哈夫曼树的创建：
从数据中，选出最小的两个，合成一个一个新数，构成树，以此类推。
在表格中创建时，要注意选中数据的摆放顺序，要么先选出的在前，或小的在前。

然后是离散：
先复习的集合幂集合计算，好吧，整个集合一章都漏掉了，以后再补上，今天不是重点。
主要是新课，第三章二元关系，下面说下：
直接说最重要的内容，关系的特性（也是学的最迷的部分）：（以下x皆属于定义域）
自反：自反关系可以理解为一个为R二元关系中，从域A引入值x，可以在域A中找到值x，即可。（但感觉还有一种解释也行：在一个二元关系中，带入x，构成xRx，如果前式为真，则有自反性）
反自反：反自反顾名思义，从定义域引入任何一个值x进R，都不能在域A中得到值x，即为反自反（类比自反性，也有第二种解释，下同）。
对称：从域A中，向R中引入x,y，可以找到yRx.
反对称：
传递性：参见大于小于等于关系。


注注注：此处知识还需加强，离掌握还差的远。


10月19日：今天先记录前几天16日-18日没记录的内容，然后再完善以前没写完的。
今天主要上了数据结构，讲了链表，堆栈，队列的一些细节知识，下面就回忆写下来：
先评讲了上次的作业，其中有一个地方值得注意：
在双向链表插入元素操作中，在中间插入都还简单，但若是插在链表尾部，此时插入操作会不同，就得用if（p->next==NULL）来另外写插入语句，最主要的是在此时没有修改前驱指针的操作，因为p->next为NULL，当然就没有p->next->prior。

写了一些题，双向链表插入，删除时，指针的修改（此处的注意事项就是之前总结的:修改顺序是从后向前，从新节点到旧节点）。
还有一些关于队列的题不是很熟，有一题是将队1中的元素出队，经过一个if（q->num[i]!=m）语句筛选后入队2，该算法的用途就是将队列1中值为m的元素删除。
还有一道是先在一个循环中将队1出队，存入队2，同时m++，记下队1的长度，再在一个循环中，将队2出队，存入队1，队2，最后效果是将队1元素复制到队2（那m有什么用？？？）。

然后就是栈堆的应用：
1.逆序储存：由于栈有LIFO的特性，按顺序存入后，输出时就为逆序。
2.当有n个入栈元素时，共有C(2n,n)/(n+1)种出栈序列。

最后是树：
树的的先序，中序，后序存储在数学中的应用都先不说，只说通过中序序列和另一种序列推出第三种序列的方法：
首先看不是中序的序列，前序就看第一个字母，后序看最后一个字母，因为这个字母就是树的根节点，然后根据中序排列将左右部分的元素分开，然后分别根据另一序列确定第二层节点，以此类推，层层确定即可。

10月24日：
昨天复习了模电，只复习了知识，还没做题。先记下来，再练题。
先是电容，电感，虽是一前一后，但我觉得要对比来看：
和中学一样，在交流电充能时，电容视为通路，电感视为断路。放能时，电容视为理想电压源，电感视为理想电流源，然后按照第一章的计算。
接下来是公式（最恼火）：
分别都有求换路前后电压电流的积分公式，但应该不用，换路定则中的公式才是计算用的。
换路公式还不熟，然后开始练题。

先列一个欠账单：（以现在为止）
电子：第二章电容电感未练习，第三章正弦交流、、全部，第五章二极管、、全部。
离散：第一章推理论证部分未练习，第二章集合、、全部，第三章二元关系、、全部。
数据库：第一章建表理论，第二章建库方法思想，第六章SQL语句、、全部及练习。
JAVA:全部。
数据结构：链表升级练习，堆栈，队列练习。树，图练习题。

模电计算：主要是四个公式，还有三个时间点的意义。
零输入响应电路：没有外部能源输入，只有动态元件提供能量。
零状态响应电路：动态元件都没有充能。
t（0-）换路前一瞬间，如果是零输入响应电路，则电容视为电压源，电感视为电流源，具体值须计算；如果是零状态输入响应电路，电容视为通路，电感视为开路。
t（0） 换路时刻：一般是指开关闭合或断开。
t（0+）换路后一瞬，具体情况参上。

然后是最重要的公式：
而且只对零输入响应电路使用：
RC电路：换路后电压等于换路前电压乘以以e为底，以负tao分之t为幂的指数。（tao=R*C）而电流自然就是电压除以电阻。
RL电路：换路后电流等于换路前电压乘以以e为底，以负tao分之t为为幂的指数。（tao=L/R）而电压自然是电流乘以电阻。

然后是数据库：
先是在写作业，作业是向表中插入数据，然后按要求查询数据。主要用到的语句有：
插入整行数据：
INSERT INTO 表名 VALUES(数据)  注：数据要用单引号括起来，数据之间要用逗号隔开。若要插入多行，只能反复使用。
插入一行的某些数据，在允许为NULL或可分配缺省值的列可以不被列出来。
INSERT INTO 表名 （列名，列名）VALUES（‘插入值’，‘插入值’）
然后是数据更新语句：
UPDATE 表名
SET XX='YY'
WHERE 条件

随便记一下模电的东西，因为没怎么听懂。
先是三极管，讲了个什么材料，锗0.4，硅0.7，好像是在稳压状态的什么值。
然后是带三级管的放大电路，应该有个简化过程，可以把电路图简化。
还有个放大倍数的公式，就没了。

继续数据库，

10月30日：有是一周没写日志，也不想找什么原因，结果就是没写。
先记一下今天学的东西：
数据结构：
先是关键路径，关键路径最重要的是每个节点最早呈现时间和最晚呈现时间的算法。
最早呈现时间：就是指该项目节点最早在什么时候能开始，这取决于该到达该节点的最长时间决定。具体算法是：从第一个节点开始，每条路逐个加，到达某个节点的最大权值和即是。
最晚呈现时间：是指该节点在不影响按时完工的条件下，最晚的开工时间，同一个点，最早最晚呈现时间之差即是在该节点可以拖拉的时间。具体算法是：从最终节点呈现时间开始，逐个减去权值，即得。
以上东西用工程流程理解会更好。

然后是关键路径：这个还好算些，其中也有贪心算法，贪心算法就是指每一步都只考虑局部最优解，从而求的全局最优解。
关键路径算法：从起始点开始，每一步都写出所有入度点的值，再选择权值最小的点，再重复，每一个点都选择最小的权值和，即得。

然后是离散，感觉离散讲的东西很多，主要是定义的什么叫什么太多了，主要就是要理解记住这些定义，然后再练练题就可以了。
先回忆下再翻书吧，先是复习了一下作业，我草想不起来。
是偏序关系，良序关系，然后讲了一下作业题。
新讲的内容是什么划分，覆盖，我日记不住了。
先复习一下关系的特性，虽然以前记过了，但是很明显，又忘记了。
自反，反自反，若一个关系中所有的值，都满足xRx，就有自反性，反之则有反自反性。
对称性，反对称性，若一个关系中所有值，都满足xRx，又满足x非Ry，就有对称性，反之为反对称性。
传递性不说了。

10月31日：今天主要是两门课，信息安全数学基础和数据库。
先是数基，讲的都是有关整除的东西，而且内容都是小学就学过的，但对同一个概念，理解角度却完全不同，
先是整除关系，就有专门的符号表示：x|y，由此又有很多的衍生结论，
比如：对于一个大数，若p=x+y,且i|x&&i|y，则p可被i整除。（可以用来拆解大数）
还有素数和非素数的定义：不在是有没有1和它本身以外的因数来看，而是看在不大于该数的情况下，是否有素数可以整除该数
还有素数有无限多个的证明，就是利用了以上关系。
然后是最大公因数的算法：辗转相除法，但不是一除的形式，而是写成了被除数等于除数*m+n的形式，而最大公因数就是n=0之前的那个n值。


11月15日：又是好久没写了，刚刚看了第8节的韩顺平，主要讲了this语句和静态变量，下面记一下：
this 语句：其作用类似于中文中的 我的 ，用于强调变量的来源，在某一个对象中使用时，能够指明是哪一个变量，也就是说，this 是用于具体对象中，用于区分不同对象中的同名变量。
static静态变量：重点是其性质，不管在哪里使用都只创建一次，而且可以被任何对象访问到，即：可以在程序的任何地方修改static变量的值。

11月16日：今天又把3.1看了一遍，虽然之前也看过，但总有些迷糊，这次不光概念看完了，题也全部做了一遍。确实，做题提升对知识的理解是最快的，通过练习对关系图，指定二元关系，>=，>,IXI，以及在二元关系上，使用交，并，相对补，绝对补运算后的二元关系特性的判断，对于二元关系的判断几乎就不会有什么问题了。下面记一下今天看的内容和总结；
先是一个小知识，D(M)是指的二元关系的定义域，R(M)是指的二元关系的值域。
然后是对几个关系特性的再理解：
全域关系：是指两个集合的相等关系，不过不是很确定。
五大特性；虽然对于五个特性有文字，符号，图形，矩阵四种方法描述，但经过今天的实战体会，还是书上的符号描述要好用些，以后也就这样判断。
自反关系：将x代入关系R中，若对所有的x，关系R都成立，那么关系R就有自反性。
反自反：将x代入关系R中，若对所有的x，关系R都不成立，那么关系R有反自反性。
对称性：若关系R中存在x->y，那么就一定存在y->x的路径。
反对称性：若关系R中存在x->y，那么就一定不存在y->x，如果存在y->x，也只能是在y=x的情况下，那么关系R就有反对称性。
传递性：若关系R中存在x->y,y->z，那么一定存在x->z，那么关系R就有传递性。值得一提的是，上课学时和第一次自学时，都以为传递关系很简单，但没想到，做题时却多次出错，还有想不通的地方，实在让我没想到。
然后就是几个重点题中的要点，还有就是几个想不通的点：
空关系：五大特性中，空关系只有自反性没有。
问题：相等关系的反对称性
课后题中的6,8,9,10题都有些小问题。

11月25日：刚刚看了静态方法的隐藏，和覆盖作比较，大概是看懂了。
方法的覆盖：是指在继承时，在子类中重新定义某些实例方法，可以起到取代父类中同型方法。
静态方法的覆盖：是指如果在父类中定义了用static修饰的方法，那么在子类中再定义同名静态方法后，super类的静态方法不会被取代，而sub类中的方法则不会被调用（相当于没用，所以叫做静态方法的隐藏）注意:super类中的static方法不能被实例方法覆盖 ，隐藏。
然后是关于这两次JAVA报告的一些心得：
最让我困惑的是报告中，public的使用，以及报告中的各种命名的冲突，不过后来通过重新创建了一个public的student类，解决了这个问题。
 
11月26日：
很难受，我他妈的搞忘交数据库作业了，看来最近耍的有点凶了。
接下来写一下欠了那些复习内容：
专业课：

数据库：
基本内容没问题，但运用还不熟，语句也有些不熟。
这周六12月2号考试。

JAVA：
最基本语句会写，但几乎没怎么练过题，基础也很差。
下周六12月9号考试

数据结构：
整体知识没问题，但细节处没掌握，也有很多漏洞。

公共课：
离散：几乎全部不会。
考试时间未知。

电子：                                                                 
前两章看了一些，其他都还有问题。
大概还有2-3周考试。

信安数学：
整体还行，目前上的内容还不多。
考试时间未知。

然后安排下复习计划：
首先是数据库，JAVA，电子，
11.26：离散第六章（应付考试）
11.27：同上。
11.28（周二）：数据库(先复习语句，全部抄一遍，然后练习书上的题)，JAVA（先把网页上的题做了，）.                                                                                   


编程题：3道，简单，一般，难
类的定义，简单
类的继承，一般
接口，难

选择题全部都有。重点偏重面向对象，大小题都有。异常较少。
注意关键词。

JAVA:
 静态变量：
在一个类中定义一个静态变量，所有的同类变量都可以访问，是所有同类类共享的，但在静态方法中无法访问非静态变量。
静态方法也可以被所有的相同的类和对象访问到。

封装:将类变量和类方法封装，使得该程序的其他部分无法直接访问，只能被授权之后，才能访问，常用的方法是，通过成员方法来访问，如get()方法，get方法类用return 返回想要访问的变量。

变量修饰符：
共有的：
私有的：
保护的：
默认的：

练习：职员信息保密，

11月28日：复习数据结构第8章全部内容，刚刚看完，现在开始整理：
1.插入排序：
直接插入排序：先将这组数据的第一个数视为一个有序数列，然后通过每次插入一个数的方法来使整体数据有序。
值得注意的有以下几点：
1，在循环中，使用一个temp的变量来存储要插入的数据。
2，进行插入比较时，要从插入数据的前一个数据开始比较，因为这样比较时，当比较到有数据比插入数据小时，就可直接跳出内层循环，开始下一轮插入操作。
3，进行比较后，如果当前数据比插入数据小时，插入数据存入上一位置，比插入数据大时，则将当前数据移动到上一位，再继续向前比较。
4，边缘条件：外循环：for(i=1;i<=lenth;i++)注意外循环里i是从1而不是从0开始的。内循环：for(j=i-1;j>=0;j--)由于是倒着比较，故为j>=1,j--。
5；时间复杂度：O(n的平方)，空间复杂度：O(1).

希尔排序：是插入排序的改进版，通过增加一个增量d来使数据大跨度的交换，更快的到达最终位置。
具体代码没看，但我知道是通过对增量d--的操作来逐渐缩小范围，直到d=1时，变为一个直接插入排序，但和直接使用直接插入排序不同的是，经过前几轮的交换（也就是对间隔为d的数据进行插入排序后），该数列已经基本有序，再使用直接插入排序可以节约时间成本。

2.交换排序：
冒泡排序：C语言中会的唯一一种排序方法，不过现在才想清楚，冒泡排序还是分两种的：沉底和上浮。
沉底：从第一个数据开始，和下一个数比较，若前一数据小于后一数据则不换，反之则换，但不管换与不换，都将游标指向下一位，直到倒数第二位和最后一位比完，再跳出循环。此时，该数列中最大的数已经沉底，所以，下一次循环时的后界就要减一。
上浮：应该和沉底是反的。

快速排序：快速排序中定义了一个疏轴的概念，通过疏轴将数列分成两部分，从疏轴右边的末尾开始进行比较，交换数据后，改变方向，从左边第一个开始比较，当疏轴左边选中数据大于疏轴时，将疏轴与该数交换，然后从疏轴右边段末尾开始比较。
代码实现：
在主程序中，就按部就班的写，外函数只调用一次，而内函数不在主函数中调用。
在外函数中，需要传入first,end 两个值，首先会调用内函数，然后两次递归调用自己，传入的值分别是：（first,mid-1）和（mid+1,end）,而mid的值就是在调用内函数时的返回值。
最核心的算法在内函数，内函数接收到first和end的值，并将first对应的数据视为疏轴，开始比较。比较和交换通过两层循环实现，第一层是判断first<end，而终止情况是first=end，意为此时疏轴已到达最终位置。第二层是完成对每一段的比较，先在疏轴右端末尾开始比较，因为定义时已把第一个数作为疏轴，此时只有右边有数据。当右端比较时，大于疏轴则end--，小于疏轴则将小于的数据写入疏轴当前位置，然后将交换数据的位置作为疏轴的位置。然后进行在左端的循环，同样的道理，只不过是从第一个数据开始，为first++，由于外循环和两个内循环都是使用while，所以循环次数不必注意，只要边缘条件正确即可。最后，在外循环跳出，内函数返回值前，要把疏轴pivot的值赋给a[first],此时first=end，赋给谁都是一样的。

3，选择排序：
简单选择排序：对一个序列进行扫描，每次选出无序部分的最小数，与无序部分第一个数交换，直到只剩一个数据没插入，即可。
代码实现：
对整个数列进行比较，两层循环，外层循环i值代表当前有序的下一位，即要与最小值交换的数，选出最小数，记录下下标，若该数的位置不为最终位置，则与有序部分的下一位交换，反之则不。通过if中的flag变量来记录是否需要交换。

堆排序：通过完全二叉树来排序，先将序列表示成完全二叉树，在从最后一个非叶子节点开始，（此处以大堆顶为例）将此节点和其叶子中的最大值找出，作为子树根节点。以此类推，直到根节点。
没看代码。

4，归并排序：归并排序也要用到递归思想，先把数据分为两个或多个部分，然后在各部分中排序，然后再将两个或多个有序序列合并排序，由于此时各部分都已经有序，合并时可大大降低比较次数。

5；基数排序：按一定的先后顺序使用关键词，对数据排序。值得注意的是：在这种排序中，越后作用的关键词优先级越高，在排序依据中更重要。

12月4日：刚刚游戏打够了，现在写一下前两天复习网页制作和学习PHP的内容。
主要是为了工程实践，也顺带写一下博客。复习html还没什么，毕竟是学过的，但在看php时遇到了瓶颈，不仅看不懂，也不知道怎么嵌入html的代码中，这也是当下工程实践最大障碍，应该是因为还没太了解这门语言的缘故吧。那么，我怕是要系统的了解一下这门语言了，哎，又要费时间。
html：具体语法还是挺简单的，看书很容易看懂，只是东西有点多，用途很繁杂，具体用的时候再查书吧，语法就不记了，没什么用。
所以，接下来的时间就学习一下php吧。
一小时后：刚刚看了一下PHP的介绍，说的很厉害，大概是因为它可以完成几乎所有的编程任务，虽然，某些方面不是最好的，但胜在功能强大。其中很重要的就是和数据库的连接，以及嵌入html的代码中，这也是我现在要主攻的方向。不过，新问题又来了，好像大多使用的是My sql，而不是SQL server,不过还需再了解一下，今天先睡了。

12月7日：感觉这几天有点空虚，打游戏，看小说，构思世界，好像都不能消除，也就只有学习时才能缓解。下面记一下这几天看的东西吧。
首先是数据结构，但没怎么看进去，就不记了，然后是PHP。
这两天也没看太久，但对于PHP这门语言也有了一个了解。这门语言最初是定位在编写页面的脚本语言，但后来引入public,private,protect这类关于面向对象的关键词后，也具有面向对象编程的能力。而且书上介绍好像都是用PHP和My Sql连接的较多，毕竟是免费的。而PHP连接数据库好像也只是调用几个函数就行了，这也是我这次学习的最基本目标，至于其他能到哪就到哪吧。
最后是java,星期六考试，网页上的题大都很简单，只是全英文的题还是有点伤，不过大概也就那几个词，二三十个也不是很多，然后JAVA的其他知识也没咋看，哎，这两天。

12月11日：今天终于看了些干货了，可以好好写两笔了。刚刚看了一节离散，是第8章第一节，还有第二节没看，打算一起看了，这样下一节课可以跟上，第8章最后就不复习了。下面记一下内容。
第一节大都是介绍一些名词定义，重要的大概有以下一些：
底图：把有向图的弧转化为棱，得到的无向图就是该有向图的底图。
然后是对图的分类：
含有平行边的图为多重图，而非多重图即为线图（应该是线性对应的意思），也就是不含平行边的图。
简单图：不含自回路的图。（但可能会有孤立节点等）
平凡图：只含一个节点的图。（可能有自回路）
出度，入度，度数的概念很重要，但数据结构中学了，也不是很复杂，也就不记了。
然后是各种特殊的图，而且顺序是越来越特殊。
正则图：每个节点的度都一样，度为几就是几正则图。
图的同构：两个图的节点集，边集相同，且对应点的度也相同，即称两图同构。书上的定义时必要不充分的条件（度相同的点数目相同）。
图的运算和集合的运算一样也不记了。
删除边和删除节点：不同点是删除节点时要一同删除邻接的边。
子图：刚刚还和同构给记混了，一个图的节点集和边集都包含于另一图，则称该图为另一图的子图。
真子图：在满足子图定义的定义下，该图不等于原图。
生成子图：点集相同，但边集包含的子图。
有向完全图:所有节点两两相邻接的有向图。
无向完全图：参上。
最后一个，补图：节点和原图一样，但边集与原图关于同节点数完全图互补。

周末时候看了电子第一章，现在记一下：
1.其中计算中需注意的是关联方向，正负一定要注意。

2.先是电压源。电流源，电阻一类基础，然后就是基尔霍夫电压电流定则：
电流：对于任意一个节点，流入节点的电流之和等于流出节点的电流之和。
电压：对于任一闭合回路，按照关联方向计算，电压升=电压降。也有推论：对于闭合回路中的任意两点间电压，等于该回路中其他电子元件电压之和，不是相反数。

3.单口网络大概就是关于电源的内部构造的等效判断。
然后是电压源，电流源的等效：
电压源：与电压源串联时，电压等于所有电压源之和。与电阻串联时，电阻不可略去，且与其他电压源串联合并时，电阻相加，与电阻并联时，电阻可省略。与电压源并联时，必须是和电压大小方向都相同才行，而且效果和单个电压源一样。
电流源：与电流源并联时，电流等于所有电流源之和。与电阻并联时，电阻不可略去，且与其他电流源并联合并时，电阻相加，与电阻串联时，电阻可省略。与电流源串联时，必须是和电流大小方向都相同才行，而且效果和单个电流源一样。

4.最后是很重要的实际电压源与实际电流源的等效：
电压*电阻=电流*电阻
利用该定理可以将多电源的电路化为只有一个电压源或一个电流源与一个电阻的单电源电路，与之后的叠加定理同为化简电路的方法。注意合并后的电源极性。

5.叠加原理：
在一个多电源的电路中，所有电源产生的效果等于这些电源单独作用时的效果之和。具体到电压源，电流源也没啥好说的，加起来就行了，只是要注意符号正负就好。

6.最后一个戴维南定理有点像单口网络的定义，只不过单口好像是用在实验里的，而戴维南是用在计算中的，用来把电路电源简化成只由一个电压源和一个电阻串联，使用电源的等效规则来确定。

12月12日：刚刚看完离散第8章第2节，现在记一下，而且今天突发奇想，要不把学习小说的感想也记一下，还可以督促文笔进步。还有学习PHP，js的学习也要记下，虽然现在刚开始很艰难，没啥实质进展。
离散第8章第2节：
先是介绍关于路径，回路的定义。
简单路径：每一条边都不重复出现的路径。
基本路径：每一个节点都不重复出现的路径。
简单回路：没有出现相同边的回路。
基本回路：没有节点重复出现的回路。（此处的起始兼结束的点）

然后是这一节的第二个重点：连通
先是关于连通的基本定义：
若任意两个节点都存在路径可达，则称该图是连通的。
连通分图：对于图G，最大的连通子图即是图G的连通分图，简称分图。但最大不代表只有一个，可以有多个子图互不包含也可以，而且这种情况还偏多，具体数量用w来带替。
大头来了，点割，泛点割，割点；割集，泛割集，桥的定义。
对于图G，去掉一些节点，使得图G不再连通，这些去掉的点的集合称为泛点割（可能会有多个），而其中最小最少的集合称为点割，若只有一个点则称为割点。
对于图G，去掉一些边，使得图G不再连通，这些去掉的边的集合称为泛割集（可能有多个），而其中元素最少的集合称为割集，若只有一条边则称为桥。
不对，刚刚看到后面的点连通度的定义，按刚刚的理解就有问题，点割不是唯一的，点割，泛点割的定义搞错了。
应该是跟分图的定义类似，最小不代表只有一个，而是对于每一种去掉节点方法，都存在最小的去掉节点的数目，即为点割，但又有多种方法（或者说顺序）去节点，所以就有多个点割，而点连通度就是这些点割中最小那个的去节点数。
而连通度的定义和点连通度的定义类似，就不在说了。
然后强，单向，弱，三种连通的定义和包含关系。
强连通：在有向图中，任意两点之间都可达。
单向连通：在有向图中，任意两点间至少存在一条路径可达。
注意强连通，单向连通都是对于有向图而言，接下来的弱连通则是对于有向图的底图。
弱连通：若有向图的底图是连通的，则称该有向图是弱连通的。
但以上定理的逆都不成立。
至于强，单向，弱分图，自不必言。

然后欧拉路径和欧拉回路，
欧拉路径：穿程于（这个词很精辟）图G中，每条边都经过且只一遍，的路径称为欧拉路径。
欧拉回路：若欧拉路径是个回路，即为欧拉回路。
判断无向图是否有欧拉路径：度为奇数的点是否有偶数个，为偶数则有欧拉路径。
判断无向图是否有欧拉回路：所有节点的度必须为偶数。
判断有向图是否具有欧拉回路：当且仅当所有节点的出度都等于入度时，但可能有两个节点例外，一个节点入度比出度大1，另一个出度比入度大1。

12月13日：今天的空余时间几乎都砸在博客上了，但时间轴还是没做出来，是不是方向错了，可能按表格的做法来安排要容易些，下次写再改吧，这段时间要复习电子了。接下来记一下今天上课时学的离散第8章第3节：
先记下第2节最后的哈密尔顿图：
和欧拉图的概念相似，哈密尔顿路径的定义是：对每个节点有且只经过一次，即称哈密尔顿路径，而回路即称哈密尔顿回路，该图称为哈密尔顿图。
判断无向图中是否有哈密尔顿路径的方法（好像有点问题）：从一个节点开始，用A,B轮流标记相邻节点，若最后A,B的数目相等，则有，反之则无。
判断无向图是否含有哈密尔顿回路：每一对节点的度数之和都大于n（节点数）。
最短哈密尔顿路径：和数据结构中的贪心算法一样。

然后是第8章第3节：图的矩阵表示。
先是几个图的基本定义：
逆图的矩阵：原图的邻接矩阵的转置矩阵。
A*AT含义是：引出的边结束在同一顶点的节点数。更正解释：最后的到得的矩阵中，行和列序号代表起始节点，矩阵中的数代表始点为这两个节点的数目。
AT*A含义是：和前一定义相反，行和列序列代表的是最终节点，而矩阵中的数代表的是终点为这两个节点的数目。
A(n次方)：代表该图中，从vi到vj的长度为n的路径的条数。值得注意的是：该矩阵可以用来判断两点之间是否可达，当n=节点数时，若vi，vj仍为0，则两点不可达。
最后是可达性矩阵，图中两点若可达，则为1，反之为0，其实是An图的翻版。
该矩阵的用处在于从P交PT中全为1的矩阵即为最大强分图，而从主对角线上可看出原图有几个强分图。


12月15日：先记一下有哪些要写日志的：离散第3节（完成），电子第2章整理，第1章作题总结。
先记电子第1章的作题总结：最最最重要的是：关联方向和符号正负。这在做题中也不知道错了几次了，浪费时间。
然后是叠加定理的应用，不是很难，但还是卡住了，主要的原因是基尔霍夫电压电流定理用的太少，总找不到下手的地方，但仔细找下又还是做得出来，由此可见是掌握不好的原因。
看来前几年的题还是要做下才行。

然后是电阻串并连。这个倒没啥大问题，只是计算时约分还错了一道。

然后是叠加定理和戴维南定理，刚看完知识时，觉得戴维南定理只是个等效电路而已，但做了题时才发现不对，这戴维南的题是这一章中最麻烦的，先要用到叠加定理求出等效电压，然后再把电源置0，最后再带入一开始就拆除了的外电路电阻，计算即可。
但每一步都还不是很困难，做题时卡了主要是还没发现戴维南的正确用法，以及电路中的那个蛇皮正方形并联电路，再加上拆除外电路，算电阻和电压时，实在是太诡异，今天太晚了，周末和第2章，还有今天的离散一起记。

1月21日：
前天看了考试成绩，挂了3科，明天就要去新都挨骂了。
今天先记一下这两天看JAVA的一些可能会用到的东西。
按顺序来：先记各种数据类型，然后是运算符，再就是从第一份笔记中看的一些东西。
数据类型：从小到大
byte：最小的数据类型，只有1个字节，在参与运算时，会转换成int型。
short:2个字节，
int:4个字节，
long:8个字节，
char:2个字节，而且可以用来存放汉字（由于编码的原因），
float:单精度浮点型变量，4个字节，但注意java中的浮点型数据都是默认double型，若要使用float型数据，则要在小数后加f
double:8个字节，精度更高。

然后是数组，以前在两个JAVA视频中都有关于数组的讲述，但学C语言时，感觉数组并不难，而且也不是很常用，现在想想真的是坐井观天了，看来数组不管在哪种语言中都很重要，要熟练运用的。
一维数组：没什么好说的，
二维数组：其实基本概念也没什么好说的，但第一份笔记中，写了二维数组每一行包含的列不需要相同，刚开始还没懂，后来想应该是指每行定义的列数不需要相同，以后可能会用到，记一笔。

然后是位运算符，以前学C语言时也没好好学这一块，现在先记一下有些什么，用到时，再结合实例细学。
按位与：&
按位或：|
按位异或：^
按位取反：~
左移：<<
带符号右移：>>
不带符号右移：>>>

然后是几个常用术语的定义：
OOP：面向对象编程，也是java的核心编程思想，不过不好理解，刚开始学时，我还当成是面对用户的意思，实际应该是指：针对需要实现的模型中的一个个个体的意思，而编程时，就是把一个个个体单独编写出来，再用这些个体来组成整个模型。
与之对应的面向过程编程则是另一思想，说实话还不懂。

入口函数：几乎每个java程序都有的，虽是个函数，其实是整个函数的入口，代码如下：
public static void main(String []args)
public:是访问限制符，同类，不同类，同包，不同包都可以访问。后面可能会统一记一下这些基础知识。
static:指明该函数为静态函数，和不同方法不同的是，这些静态的方法或变量不用实例化就会存在，并且可以通过实例中的方法访问，但静态方法却只能访问静态变量，方法。
void：该函数无返回值，
String []args：为使用者和程序交互提供路径（然并卵，不懂）

构造函数：以前学时几乎没懂这是个啥，现在大致知道了，就是在通过类模型定义实例时（也就是实例化），给类的变量附一个初始值，之后可以根据需要修改，如果不写构造函数，编译器也会设置一个为空的构造函数。

方法的重载：
是用在子类的方法和父类的方法不同时使用，重载的方法和原方法名相同，通过方法的参数个数，类型（也可两者都不同）来区分。而编译器会选择对应匹配精度最高的使用。

几种代码块的定义：（大括号之间）
普通代码块：没有定义变量的代码块。
构造代码块：定义类中变量的代码块。
静态代码块：定义静态变量的代码块。

内部类是一种很玄学的玩意儿，顾名思义，但可能会用到，就不记了。


1月27日 信安总结
第一章 整数的可除性
第一节 整除
介绍了整除的写法：b|a表示a能被b整除
第二节 最大公因数
其他的都是常识，欧几里得算法就是辗转相除法
其中有一种题型和两个知识点
题型：（a,b）=at+by,求t,y
解法：先把a,b使用辗转相除找到最大公因数，再从倒数第二个式子开始（也就是最后一个余数），每一步都把上一步的余数换掉，直到式子中出现a,b即可。

知识点：
1既不是素数也不是合数。
（a,b）=1＜=＞at+by=1。（t,y唯一）

第三节 最小公倍数
记住形式就好：[a,b]=x（最小公倍数）。

第四节 基本算数定理
也没啥，就是任何一个数都可以用不同素数的指数来表示。


1月31日：
刚刚看了一个JAVA的笔记，介绍的都是一些有关程序编译的东西，还是有些用的，记一下。
字符串的值是用双引号括起来，如：String a="sjfdklsfj";
JAVA的控制台编译，以前看视频时，也不太懂。
javac 源文件名.java  是编译java文件
java 主类名（实际上和源文件名一样，因为命名规则） 是执行该类（必须要有主函数，public类）

带包运行指令：javac  -d  源文件名.java 
带包执行指令：java -d 主类名
执行带包类时，要加路径。（后面补充）

2月2日：
（韩顺平第11讲）
方法的覆盖：具体的内容已经记过了，但有一个注意事项。
范围问题：子类方法在对从父类继承的方法进行重载时，其重载后的方法范围必须大于等于原方法，也就是访问限制符的大小。（复习一下：public>默认的>protected>privete）

约瑟夫问题：也是丢手帕问题，具体内容就不说了，很简单。但在解决问题时，用到了结构体，链表，指针，以前在学校学时，我竟然天真的认为JAVA中没有这些东西，哎，游戏误人啊。
先说结构体，在今天看的实例中，他是定义了一个类，而这个类中有两个属性，一个是编号，一个是nextchild，顾名思义，就是下一个孩子，实际上是用来存放下一个孩子的地址。再通过循环和引入的参数来创建不同的孩子。
然后是链表，之前已经有了创建结构体的办法，于是在循环中加入给nextchild这个属性赋值的语句就行，如temp.nextchild=ch;虽然没有指针的形式，但作用和链表已经一样了。
另外还必须得说的是，创建一个类作为结构体和创建一个对象不是一回事，和C语言不同的是，JAVA中创建完了类后，还要在主函数中创建新对象，类只定义一次，但对象就是根据需要来确定的，不过应该大都是用循环体来创建的。
还有一个以前不知道的东西，就是参数的设置，比如这个例子中的：
public Kset(int k)
{
       this.k=k;
}
这个方法就是用来从外部引进参数k的值，同时又可以保密k的值不被外部方法访问到。以前写报告时，一直似懂非懂这东西有什么卵用。
约瑟夫问题中有个边缘条件需要注意，每个开始数的人都是从自己开始数的，所以边缘条件从1开始，还不加等号。

最后是很重要的编程思路的问题，以前也一直没注意：
在编写之前，要把解决问题的方法弄清楚，而且要分成一步一步，然后再一步步的编程实现，这样思路会清晰很多。

（韩顺平第12讲 ）
多态的定义：通过指向父类的指针来调用子类的方法。就可以实现如同：Animal ch=new cat();

然后是对于eclipse的发展历程介绍，eclipse是一个叫iBm网站编写的，在eclipse刚出来时，只能用于编写JAVA和C的程序，很局限，但由于太好用了，一个小公司叫myeclipse开发了一个插件，在下载后，就能编写各种程序，如JSP等等。

多态的实现
主要是通过两个实例来完成演示，
第一个实例较简单，只是用一个Animal父类，通过继承来创建Cat,Dog类，并且在这两个子类中进行方法重载，然后再主程序中进行定义和调用时，通过Animal ch=new Cat();的语句进行定义对象，这样做的原理是：编译器能够通过父类的方法，以及继承的关系，找到子类中的重载方法，当然，若没有重载方法，就会调用父类的方法，也不多态了。

第二个实例有些复杂，但也不是很难理解，承接第一个实例的代码，这个实例中，又加入了食物Food,主人Master,两个类，并且Food类中，用showName方法，同时还有鱼fish,骨头bone两个子类并进行方法重载,Master类中，有喂食Feed方法。重要的在主函数的调用，通过代码来看吧，不好叙述：
Feed 方法定义
Feed(Animal ch,Food f)
{
   ch.cry();
   f.showName();
}

主函数调用：
Master a=new Master();
a.Feed(new Cat,new fish);

2月6日：（韩顺平第13讲）
抽象类：和现实中的抽象定义一样，抽象类也不能被实例化，仅仅是作为一个供其他类继承的模型而已。
代码实现：
抽象类的定义：抽象类需要用abstract修饰，而且抽象类中没有主体的类（即未被实现），其中的抽象方法也要用abstract修饰，但也可以有非抽象方法存在，这些方法可以实现。
抽象类的使用：抽象类的子类通过继承获得抽象父类的方法，但和普通继承不同的是，抽象类的子类需要重新定义实现这些方法。这所以继承抽象类，是为了在调用时，方便使用多态（参上一讲）。只需通过父类一个，就可以调用所有的子类，比重载更加简洁明了。

接口：
接口的定义：使用interface(也是接口的英语)，接口中定义的方法都不能实现，（有点像抽象类，但抽象类可以有实现了的方法，接口一个都不能有），而使用接口的类必须实现接口中定义的所有方法，若接口是继承的，那么连同其父类方法也要实现。
接口的调用：在我看来，接口的用处就是可以不通过继承，就让没有关系的类能够相互调用方法，也就是达到类似多态的效果。
代码实现：
接口定义：
interface Usb {
        method1();//无主体
        method2();
}
接口实现：
class Camera implements Usb{
        method1(){
	
	}
        method2(){
	
	}
}
接口的继承：
和类的继承一样，interface Aaa extents Kkk{
}
接口使用：
在需要使用接口的类中定义方法
public useUsb(Usb usb){
         usb.start();
         usb.stop();
}
主函数中必须要实例化所有要用到的类，不管是调用还是被调用的类。然后再使用接口调用方法。
注意事项：难得记，就直接抄了，不难理解
1.接口不能被实例化。
2.接口中的方法不能有主体。
3.一个类可以实现多个接口。
4.接口中可以定义变量，但默认这些变量都是static，并且是final的（虽然不知道是什么鬼）。实际使用中，一般将静态变量定义在接口中使用。访问方法：接口名.变量名。
5.接口不能继承类，但接口可以继承接口。



2月8日：（韩顺平14讲）
继承和接口对比：
继承在复制父类时很快捷，但由于父类和子类之间的连带关系，如果父类出错或需要改动，那么所有的子类都将受影响。接口却只是方法层面的关系，可以任意的改动内容，可以无限制添加实现接口的类，这样其他类就可以调用这些接口方法。

课程中使用的实例是销售汽车，先定义一个关于汽车的接口，然后不同的车分别再实现接口，然后再由一个汽车店的类调用这些方法。

然后是前后期绑定：
前期绑定：相对于编译器来说，在没运行时就明了的变量值，就是前期绑定。
后期绑定：在运行后编译器才能知道的变量值。

final的使用：
final修饰类：该类无法被继承。
final修饰方法：该方法无法被重载，覆盖。
final修饰变量值 ：该量为常量，值不变。常量命名一般为XXX_xxx.




（韩顺平16讲）
对象数组：和普通数组一样，是用来存储同类型数据的数据结构，只不过对象数组存储的是对象而已。其实际原理和用处和链表相似，数组中存放的实际是指向对象的指针。
dog[i]=new dog();问题：由于对象数组只是分配了空间，实际仍是空的，不能直接赋值，要重新定义才行，也就是再为每个对象分配空间。（没想通就先记住）
异常抛出：后面会详细讲，不过听上去好像后三种异常，而在实例中使用的处理异常的方法就是不管，让别人去处理，就是异常抛出。
控制台输入：用了一个很长很怪异的语句，没用Scanner，可能是另一种从控制台输入的方法。
流：不懂。
字符String转float：使用的语句是：
float weight =Float.parseFloat(s_weight);
weight是此时专门定义的，用来存储转换类型后的值
s_weight是之前用来存储字符型值的变量，所以加了s_来命名，而数值型则没加。

for循环重复定义两个i，不会冲突，但不知道为什么。



（韩顺平第17讲：排序）
字符串比较


（韩顺平第30讲：布局管理器）
共有三种布局管理器
边界布局
流式布局
网格布局




（初试坦克大战）
布局管理器：
1.定义组件
继承JPanel，在MyPanl中完成界面绘制。
覆盖JPanel中的画笔类。可以理解为画图工具中的画笔。
调用父类方法完成初始化。
开始绘制。
让主类继承JFrame。
实例化MyPanel。
在主类中定义构造方法

创建Tank类：
定义坦克的横纵坐标（以左上角为准）以及从外部获得参数值的构造函数，用于所有坦克继承。
创建Hero类，继承Tank类，并调用父类的构造方法初始化。（记住定义在构造块（占坑），赋值再构造函数（填东西））。
在面板类中实例化英雄坦克类，同时传入参数（实质只是位置点的坐标，图形此时还没画）。（实例化对象并不需要一定在主类中）


事件处理机制： 
1.在引进包中增加java.awt.event.*;
2.事件发生源是MyPanel,监听源是继承自JFrame的3.Demo,因为JFrame更加靠近底层。
4.实现KeyListener接口,用提示。使用该接口中的按下方法。
5.在主类的构造函数中注册监听，
6.事件处理：在接口方法中用if语句和键值比较。
7.图像移动：在接口方法中对横纵坐标加减，并并在press方法中调用repaint函数来重绘：this.repaint();
总结：
关于事件源，事件对象，事件监听器的关系
事件源：发生事件，并由事件监听器在事件源注册。
事件对象：传递事件信息。
事件监听器：对事件进行处理和反应，也就是根据需要重载事件方法。

坦克绘制的封装：
通过在MyPanel中定义绘制函数，并传入位置参数，方向，以及最重要的画笔，才能绘制。
可以通过多个switch来选择坦克类型，颜色，方向等属性。



2.创建组件（在构造函数中完成 ）
3.添加组件
4.设置窗体属性（定义大小）
5.显示


2月21日：









http://blog.csdn.net/z957250254/article/details/52664620











































